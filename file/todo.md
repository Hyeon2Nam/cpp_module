## 상속

상속이란 다른 클래스의 내용을 그대로 포함 할 수 있게 해주는 작업을 뜻한다.

클래스가 A, B이렇게 두개가 있고, B가 A를 상속받는다고 가정을 했을때,

```cpp
class B : public A
{
	/* code */
}
```

이렇게 작성을 하면 A클래스를 퍼블릭 형식으로 상속받겠다는 뜻이 된다.

파생 클래스는 기반 클래스를 물려받기 때문에 기반 클래스의 멤버함수들을 사용할 수 있다.

```cpp
class A
{
private:
	std::string s;
public:
	A() : s("A") { std::cout << "A class" << std::endl; }

	void myName()
	{
		std::cout << "My name is " + s << std::endl;
	}
};

class B : public A
{
private:
	std::string s;
public:
	B() : A(), s("B")
	{
		std::cout << "B class" << std::endl;

		myName();
	}
};
```

파생 클래스에서는 기반 클래스의 생성자를 먼저 호출을 하고 파생 클래스의 생성자를 호출을 한다. 기반클래스의 생성자를 적어놓지 않을경우 암무적으로 기반 클래스의 디폴트 생성자가 호출이 된다.

그래서

```cpp
int main()
{
	std::cout << "====" << std::endl;
	A a;
	std::cout << "====" << std::endl;
	B b;
}
```

위 코드를 실행을 시켜보면

출력 결과로

```
====
A class
====
A class
B class
My name is A
```

이렇게 출력이 되는 것을 알 수 가 있다.

파생 클래스에서 생성자를 호출할때 기반 클래스의 생성자를 호출 시킨다고 위에서 말했기때문에 A클래스의 생성자가 호출되고 B클래스의 생성자가 호출이 된다고 말했다.

하지만 자기소개는 B가 아니라 A라고 하는데 그 이유는
myName이라는 함수가 A에만 정의되어 있기때문이다.

```cpp
class A
{
private:
	std::string s;
public:
	A() : s("A") { std::cout << "A class" << std::endl; }

	void myName()
	{
		std::cout << "My name is " + s << std::endl;
	}
};

class B : public A
{
private:
	std::string s;
public:
	B() : A(), s("B")
	{
		std::cout << "B class" << std::endl;

		myName();
	}

	void myName()
	{
		std::cout << "My name is " + s << std::endl;
	}
};
```

그래서 이렇게 B에도 myName이라는 함수를 정의를 해주면

```
====
A class
====
A class
B class
My name is B
```

제대로 B라고 출력되는 것을 알 수 가 있다.

이렇게 되는 이유는
함수의 이름이 같아도 서로 다른 클래스에 정의가 되어 있기 떄문에 일단 별개의 함수라고 취급이 된다.
그리고 같은 이름이라도 가장 가까이 있는 함수를 호출시키기 때문에 B클래스에 있는 myName함수를 실행 시킨 것이다.

이것을 바로 **오버 라이딩** 이라고 한다.

B클래스가 A클래스를 물려받아 사용을 한다고해도 기반 클래스의 private안에 있는 것들은 사용할 수 가 없다.

애초에 private은 자신 클래스 말고는 접근할 수 없기떄문이다.

그래서 접근 지시자가 private, public 말고 protected라는 또 하나의 지시자가 있다.

- private - 자신의 클래스만 접근 가능
- protected - 기반 클래스와 파생클래스만 접근 가능
- public - 다른 클래스도 알 수 있음

```
class B : public A
class B : protected A
class B : private A
```

그래서 위에서 클래스를 상속받을 때 썼던 접근지시자도 어떤 것인지에 따라 다르게 작동을 한다.

- public일 경우 기반 클래스의 접근 지시자들은 영향없이 그대로 작동한다.
- protected의 경우는 public 이 protected 로 바뀌고 나머지는 유지된다.
- private는 모든 지시자들이 private이 된다,

```cpp
class A
{
private:
public:
	std::string s;
	A() : s("A") { std::cout << "A class" << std::endl; }

	void myName()
	{
		std::cout << "My name is " + s << std::endl;
	}
};

class B : private A
{
private:
	std::string s;
public:
	B() : A(), s("B")
	{
		std::cout << "B class" << std::endl;

		myName();
	}

	void myName()
	{
		std::cout << "My name is " + s << std::endl;
	}
};

int main()
{
	A a;
	B b;

	a.myname();
	b.myname();
}
```

이렇게 했을 때 컴파일 오류가난다.
A클래스의 경우는 퍼블릭이기때문에 아무 문제없이 실행이 되지만, B클래스의 경우는 A에 있던 것을 private으로 받아왔기때문에 외부에서 접근이 불가능해 컴파일 오류가 나는것이다.

https://modoocode.com/209

## 업 캐스팅

상속은
파생클래스가 기반 클래스의 모든기능을 포함하고(private제외)
파생 클래스가 기반 클래스의 기능을 모두 수행할 수 있기때문에
파생클래스 == 기반클래스로 보아도 무방하다고 한다.

파생 클래스는 파생을 할수록 기반 클래스에 무안가 더 더해져 구체적이게 된다. 이것을 **구체화**라고 한다.
대신 반대로 기반 클래스로 갈수록 부가적인것들이 사라지니 그것을 **일반화**라고 한다.

위 코드에서

```cpp
int main()
{
	A a;
	B b;

	A *p = &b;
	p.myName();
}
```

를 하면 무슨일이 일어날까.

처음 이런 코드를 봤을때 당연히 다른 클래스이기 때문에 컴파일이 안될줄 알았다.
그런데 결과로는 `My nams is A`가 출력됐다.

위에서 파생클래스는 기반클래스라고 할 수 있다고 했다.
그래서 포인터자체는 작동을 하는 것이였다.

하지만 중요한 점은 포인터는 기반 클래스의 객체이기때문에 기반 클래스의 내용만을 가리킨다.
그래서 B가 아닌 A가 출력되는 것이다.

B \*p로 선언했으면 My name is B하고 출력했을 것이다.

이렇게 파생클래스에서 기반 클래스로 캐스팅하는 것을 **업 캐스팅**이라고 한다.

반대로 다운캐스팅도 존재하긴 하는데
업 캐스팅 했던것을 원래 형으로 돌려주는 작업을 제외하고는
별로 권장하는 사항은 아니라고 한다.

일단 몇가지 예로

```cpp
int main()
{
	A a;
	B b;

	B *p = &a;
	p.myName();
}
```

이 코드를 실행하면 컴파일 오류가 난다.
왜냐면 기반클래스에는 파생클래스의 내용이 없기때문이다.
사실상 당연하다면 당연한 걸지도 모른다.
파생클래스는 기반클래스의 내용을 모두 받지만, 기반 클래스는 파생클래스의 내용을 받지않고 뭐가 있는지도 모른다.

````cpp
int main()
{
	A a;
	B b;

	A *p_a = &b;
	B *p_b = p_a;
	p_b.myName();
}
이런 경우에도 오류가 난다.

사실 업 캐스팅 자체도 파생 클래스에서 기반 클래스로 형변환을 하는 것이기 때문인데,
파생클래스는 기반클래스가 맞지만, 기반 클래스는 파생클래스가 아니기 때문에 서로 다른 클래스라서 초기화가 안된다.


그래서 이런경우 다운 캐스팅을 하려면 dynamic_cast라는 것을 쓴다.
C00공부할때 캐스팅 방법은 4가지가 있었고 dynamic_cast만 나중에 따로 다룬다고 써놨었는데 드디어 이제 공부할때가 왔다
dynamic_cast는 클래스 상속 관계안에서 포인터나 참조자를 다운캐스팅과 다중상속을 위해 사용된다고 한다.
보통 업케스팅 되어있는걸 다시 원래대로 되돌리기 위해 다운 캐스팅할때만 사용된다고 한다.

dynamic_cast는 한번 검사를 통해서 캐스팅 성공 여부를 판단하고 그 후 가능하면 캐스팅을 수행하고 안되면 0을 반환해 에러를 방지해준다고 한다.
그래서 안전한 형변환을 위해 dynamic_cast를 사용한다.
근데 이것도 다형 클래스만 가능하지 다형클래스가 아니면 오류가 난다고한다.
다형 클래스는 이제 또 아래에서....

https://see-ro-e.tistory.com/52
https://modoocode.com/210
https://drawdeveloper.tistory.com/103


## virtual, override
```cpp
int main()
{
	A a;
	B b;

	A *p = &b;
	p.myName();
}
````

아까 이 코드를 실행했을 때 `My name is A` 가 출력된다고 했다. 그런데 이걸 B로 출력을 시킬수 있다.
그건 바로 virtual과 override 키워드를 사용하면된다.

### virtual

```cpp
class A
{
private:
public:
	std::string s;
	A() : s("A") { std::cout << "A class" << std::endl; }

	virtual void myName()
	{
		std::cout << "My name is " + s << std::endl;
	}
};
```

myName 함수 앞에 virtual 키워드를 입력하면

출력결과로 `My name is B`가 출력이 된다.

이렇게 되는 이유는 virtual 키워드가 있으면,
먼저 컴파일러는 이 포인터가 실제로 가리키는 클래스를 확인을 한 후 그 다음에 실제로 이 포인터가 가리키고 있는 클래스의 함수를 호출한다고 한다.

그리고 이렇게 컴파일시가 아닌 런타임시에 정해지는 것을 **동적 바인딩**또는 **지연 바인딩**이라고 한다.
반대로 평소와 같이 컴파일시에 어떤 함수가 호출되는 것이 정해지는 것을 **정적 바인딩**혹은 **초기 바인딩**이라고 한다.

> 바인딩이란
> 함수를 호출하는 코드에서 어느 블록에 있는 함수를 실행하라고 해석하는 것

그리고 virtual 키워드가 붙은 함수를 **가상 함수**라고 한다.

컴파일러마다 가상함수가 동작하는 방식은 다르지만 일반 적으로 **가상 함수 테이블**이라는 것을 이용을 한다고 한다.

가상함수를 하나라도 가지는 클래스가 있으면 가상 함수 테이블을 작성한다.
기싱 함수 테이블에는 가상 함수들의 주소가 저장이되고
가상 함수를 호출하면 프로그램은 가상함수 테이블에 접근하여 자신이 필요한 함수의 주소를 찾아가 호출을 하게된다.

이렇다보니 가상함수를 사용하면 함수의 호출과정이 복잡해서 메모리와 실행 속도 측면에 부담이 간다고 한다.

가상 함수말고 가상 소멸자라는 것도 존재를 한다.
이건 업캐스팅으로 동적 할당 한것을 메모리 해제할때 사용하는 것인데
일단적으로 delete 키워드를 붙여 소멸자를 호출 시키면 파생 -> 기반 클래스 순으로 소멸자가 호출이 되야 하는데
기반 클래스의 소멸자만 호출이 되고 파생 클래스의 소멸자는 호출이 되자 않아 메모리 누수가 난다고 한다.

그래서 소멸자에 virtual 키워드를 붙여 파생 클래스의 소멸자도 호출시키게 하는 것이 가상 소멸자이다.

http://www.tcpschool.com/cpp/cpp_polymorphism_virtual

### override

파생 클래스에서 기반 클래스의 가상 함수를 오버 라이드하는 경우 override 키워드를 통해 명시적으로 나타낼수 있다고 한다.
override 키워드를 사용하게 되면 실수로 오버라이드 하지않을 경우를 막을 수 있다고 한다.
만약 기반 클래스에 가상함수 만들어놓고 파생 클래스에 오버라이딩하고 override 키워드 안 적어주면 제대로 오버라이드되지않고 기반 클래스의 가상 함수가 실행된다는 것이다.

그리고 이렇게 하나의 메소드를 호출했어도 여러가지 작업들을 하는것을 **다형성**이라고 하고 이런작업들을 하는 클래스를 **다형 클래스**라고 한다.

https://modoocode.com/210

### 순수 가상함수

```cpp
class A
{
	public:
		virtual void myName() = 0;
}
```
위 코드를 보면 재미있는 점이 있다. 가상함수가 정의도 되지 않았고 `= 0` 이 붙어있다.
이런 함수를 **순수 가상 함수**라고 하는데, 이런 함수들은 **반드시** 오버라이딩이 되어야 한다.
그리고 순수 가상함수를 한개 이상 포함하고 있는 클래스를 **추상 클래스**라고 한다.

또한 기반 클래스에서 정의가 되어있지 않기때문에 기반 클래스 객체를 생성하는 것이 불가능하다.
그래서 해당 함수를 오버라이드한 파생클래스의 업 캐스팅을 통해서만 객체생성이 가능하다.

https://modoocode.com/211


## 다중 상속
한 클래스가 두개 이상의 클래스를 상속 받는 것을 다중 상속이라고 한다.

```cpp
class A
{
	/*code*/
};
class B
{
	/*code*/
};
class C : public A, public B
{
	/*code*/
};
```
이제 C는 다중 상속으로 A와 B클래스의 있는 기능들을 쓸수있다.

생성자는 상속받을때 `class C : public A, public B`  이거 순서에 따라 적은 순서대로 호출된다.

주의할 점으로는 상속 받는 클래스들에 같은 이름의 멤버 변수가 있으면 안된다.
이름이 같으면 다중상속 받은 파생클래스에서 호출한 변수가 어느 클래스의 멤버 변수인지 모르기 때문이다.

또한 다이아몬드 상속이라는 것이 있다.

```cpp
class A
{
	/*code*/
};
class B : public A
{
	/*code*/
};
class C : public A
{
	/*code*/
};
class D : public C, public B
{
	/*code*/
};
```
이게 다이아몬드 상속이다.

어떤 두 클래스가 한 클래스를 상속을 받고
다른 한 클래스가 두 클래스를 다중 상속 받는 관계이다.

이러면 변수명 같은것이 겹치게 될 가능성도 많고, 변수 이름 같은 걸 주의해서 잘 만든다고 해도, 기반 클래스의 내용이 전부 겹치는 문제가 발생하게 된다.

그래서 다이아몬드 상속에서는

```cpp
class A
{
	/*code*/
};
class B : public virtual A
{
	/*code*/
};
class C : public virtual A
{
	/*code*/
};
class D : public C, public B
{
	/*code*/
};
```
상속 받을때 virtual 키워드를 붙여서 상속을 받아 기반 클래스를 딱 한번만 상속받게 할 수 있다.


한 클래스에서 여러개의 클래스의 내용을 사용해야할때 세가지 방법으로 클래스를 디자인 할 수 가 있다.

* 브리지 패턴
* 중첩된 일반화 방식
* 다중 상속
이렇게 세가지이다.

**브리지 패턴**
필요한 것중 하나는 멤버 포인터로 만드는 방법이다.

만약 A라는 클래스랑 B라는 클래스의 기능을 둘 다 쓰고 싶을때 멤버 변수로 A *a; B *b; 이렇게 멤버 포인터로 선언하는 방식이다.
하지만 
* 오버라이딩 개수가 N + M이 최대여서 NxM개의 상황을 체크해야할 때는 사용하지 않는 것이 좋다.
* 또한 컴파일시 타입 체크를 적절히 활용할 수 없다.

**중첩된 일반화 방식**
계속해서 파생클래스를 생성하는 방식이다.

A 클래스, B클래스를 생성하고 그 후에 저 클래스들을 각각 상속받는 C, D클래스를 생성하는 방식이다.
그래서 NxM가지 파생 클래스들을 생성 할 수 있게 된다. 그래서 섬세한 작업이 가능해진다.
하지만 기능 하나가 추가가 되면 매번 새로 작성해줘야 한다는 단점이 있다.


마지막으로 다중 상속 방식은
파생 클래스를 최대 NxM개 만들수 있어서 섬세한 제어를 할 수 있고, 해당 클래스를 사용하는 모든 클래스들을 가리킬 수 있게 된다.

하지만 이 세가지 방법중 무엇이 가장 좋은지는 정할 수 없다는 것 같다.
자신이 어떻게 쓰는지에 따라 달라질 듯 하다.


https://modoocode.com/211


## ex00
## ex01
## ex02
## ex03



```cpp

```
