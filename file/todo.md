# 공부 할거
## 보너스 룰
* 복사 생성자
복사 생성자는 한개의 객체만 생성해 놓고 그 한개의 객채만을 가지고 나머지 객체를 복사해서 생성하는 것을 뜻한다.

어떠한 클래스가 있고, 그 클래스의 객체를 상수 레퍼런스로 받아 그 객체의 인스턴스 변수들만 복사하는 것이다.

표준적으로 const로 인자를 받기때문에 복사 생성된 객체의 인스턴스 변수의 값은 변경할 수 가 없다.


~~~cpp
A a(1);
A b(a);
~~~
이렇게 a객체를 만들어주고, a객체를 사용해 b객체를 복사 생성한다.

~~~cpp
A c = b;
~~~
이런식으로 선언을 해도 복사 생성자가 호출이 된다.
하지만

~~~cpp
A c = b;
~~~
하고 

~~~cpp
A c;
c = b; 
~~~
는 다른 코드이다.

복사 생성자는 말그대로 생성자이기 때문에 생성될때만 호출이 되기때문에 위 코드만 복사 생성이 된다.


복사에는 **얕은 복사**와 **깊은 복사**가 있다.
복사를 하게되면 복사된 객체들의 인스턴스 변수는 원본 객체의 인스턴스 변수와 같은 주소값을 같게 된다.

그래서 같은 주소값을 가지고 있으면 **얕은 복사**라고 하고,
새롭게 메모리를 할당을 해서 값을 복사하는 것을 **깊은 복사**라고 한다.

https://modoocode.com/188

* 연산자 오버로딩
기본 연산자들을 직접 사용자가 정의 하는 것을 연산자 오버로딩이라고 한다.

연산자 오버로딩을 위한 함수의 프로토타입은
`(리턴 타입) operator(연산자) (연산자가 받는 인자)`
이런식으로 되어 있다.

사용할때는 기존 연산자를 쓰는 것처럼 사용하면 된다.

https://modoocode.com/202

## 00
* 부동(floating)소수점과 고정(fixed) 소수점
부동 소수점은 소수점이 움직인다는 뜻이다.
고정 소수점은 부동 소수점과 다르게 소수점이 고정이다.


소수점이 있는 수를 이진수로 변환할 떄는
소수점 앞 수들은 정수처럼 변환을 하고
소수점 뒤 수들은 정수변환의 반대로 한다.


고정 소수점 표현방식은 위와 같은 방식으로 숫자를 변환하여 저대로 메모리에 넣는 방식인데

만약 16비트를 쓴다고 하면 맨 앞자리는 부호비트로 사용을 하고 나머지는 정수부랑 소수부를 표현하는 비트로 각각 나뉘게 된다.
나눌때 소수점의 위치는 미리 정해둔다. 

소수부는 앞자리부터 채우고 쓰지않는 비트는 전부 0으로 채운다.

고정 소수점은 구현하기 편리하지만 비트 수 대비 표현 가능한 수의 범위나 정밀도가 낮아 높은 정밀도가 필요없는 경우가 아니면 잘 쓰이지 않는다고 한다.

부동소수점은 고정 소수점과 다르게 바로 변환한 결과를 사용하지 않고 졍규화라는 과정을 추가로 거친다.

정규화는 2진수를 1.xxx... * 2^n 의 꼴로 변환하는 것이다.

변환하는 법은 정수부의 1만 남을때까지 소수점을 왼쪽으로 이동시키고 이동한 칸 수만큼 n자리에 집어 넣으면 된다.

부동 소수점은 IEEE 표준에 따라 32비트나 64비트가 사용되며
맨 앞자리가 부호비트와 지수부, 가수부로 나뉜다.

가수부도 앞자리부터 채우며 남는 자리는 0으로 채운다.

지수부에 숫자를 넣을때는 2^n에 해당하는 수를 127을 더해 저장을 한다. 127은 IEEE표준에서 지정한 bias라는 지정된 숫자이다.

bias를 사용하는 이유는 지수가 음수도 될 수 있기 떄문에 그렇다고 한다.


https://gsmesie692.tistory.com/94


## 01
* roundf 함수
`float roundf(float x);`
반올림하는 함수이다.


~~~cpp
~~~
